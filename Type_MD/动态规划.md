æ¡†æ¶

1ã€æ˜ç¡® `dp` æ•°ç»„çš„å®šä¹‰ã€‚è¿™ä¸€æ­¥å¯¹äºä»»ä½•åŠ¨æ€è§„åˆ’é—®é¢˜éƒ½å¾ˆé‡è¦ï¼Œå¦‚æœä¸å¾—å½“æˆ–è€…ä¸å¤Ÿæ¸…æ™°ï¼Œä¼šé˜»ç¢ä¹‹åçš„æ­¥éª¤ã€‚

2ã€æ ¹æ® `dp` æ•°ç»„çš„å®šä¹‰ï¼Œè¿ç”¨æ•°å­¦å½’çº³æ³•çš„æ€æƒ³ï¼Œå‡è®¾ `dp[0...i-1]` éƒ½å·²çŸ¥ï¼Œæƒ³åŠæ³•æ±‚å‡º `dp[i]`ï¼Œä¸€æ—¦è¿™ä¸€æ­¥å®Œæˆï¼Œæ•´ä¸ªé¢˜ç›®åŸºæœ¬å°±è§£å†³äº†ã€‚

ä½†å¦‚æœæ— æ³•å®Œæˆè¿™ä¸€æ­¥ï¼Œå¾ˆå¯èƒ½å°±æ˜¯ `dp` æ•°ç»„çš„å®šä¹‰ä¸å¤Ÿæ°å½“ï¼Œéœ€è¦é‡æ–°å®šä¹‰ `dp` æ•°ç»„çš„å«ä¹‰ï¼›

æˆ–è€…å¯èƒ½æ˜¯ `dp` æ•°ç»„å­˜å‚¨çš„ä¿¡æ¯è¿˜ä¸å¤Ÿï¼Œä¸è¶³ä»¥æ¨å‡ºä¸‹ä¸€æ­¥çš„ç­”æ¡ˆï¼Œéœ€è¦æŠŠ `dp` æ•°ç»„æ‰©å¤§æˆäºŒç»´æ•°ç»„ç”šè‡³ä¸‰ç»´æ•°ç»„ã€‚

# ä¸€.å…¥é—¨DP



## 1.1 çˆ¬æ¥¼æ¢¯

### [377. ç»„åˆæ€»å’Œ â…£](https://leetcode.cn/problems/combination-sum-iv/description/)

```java
package ä»£ç éšæƒ³å½•.åŠ¨æ€è§„åˆ’.èƒŒåŒ…é—®é¢˜.å®Œå…¨èƒŒåŒ…;

import java.util.Arrays;

/**
 * @Author: ZJX
 * @Date: 2024/10/31
 * @Description: <a href="https://leetcode.cn/problems/combination-sum-iv/description/">377ç»„åˆæ€»å’Œâ…£</a>
 */
public class a377ç»„åˆæ€»å’Œâ…£ {
    class Solution1 {
        int[] memo;

        public int combinationSum4(int[] nums, int target) {
            this.memo = new int[target];
            Arrays.fill(memo, -1);
            return dfs(nums, target);
        }

        public int dfs(int[] nums, int target) {
            if (target == 0)
                return 1;
            if (memo[target] != -1)
                return memo[target];
            int result = 0;
            for (int num : nums) {
                if (target >= num)
                    result += dfs(nums, target - num);
            }
            return memo[target] = result;
        }
    }

    class Solution2 {
        //äºŒç»´DP
        public int combinationSum4(int[] nums, int target) {

            //nums[i] æœ€å°ä¸º1,æ‰€ä»¥lenæœ€é•¿ä¸ºtarget
            int len = target;
            int[][] f = new int[len + 1][target + 1];
            //f[i][j] è¡¨ç¤º ç»„åˆé•¿åº¦ä¸º i å…¶å’Œä¸ºj çš„å…ƒç´ ç»„åˆçš„ä¸ªæ•°
            //base case
            f[0][0] = 1;
            int result = 0;
            for (int i = 1; i <= len; i++) {
                for (int j = 1; j <= target; j++) {
                    for (int num : nums) {
                        f[i][j] = f[i - 1][j];
                        if (j >= num)
                            f[i][j] += f[i - 1][j - num];
                    }
                }
                result += f[i][target];
            }
            return result;
        }
    }
    
    class Solution2_1{
        //ä¸€ç»´
        public int combinationSum4(int[] nums, int target) {
            int[] f = new int[target + 1];
            //f[i] è¡¨ç¤º ä» numsä¸­å‡‘æˆ å…¶å’Œä¸ºi çš„å…ƒç´ ç»„åˆçš„ä¸ªæ•°
            //base case
            f[0] = 1;

            for (int i = 0; i <= target; i++) {
                for (int num : nums) {
                    if (i >= num)
                        f[i] += f[i - num];
                }
            }
            //System.out.println(Arrays.toString(f));
            return f[target];
        }
    }
}
```

ç±»ä¼¼é¢˜ç›®

####[57. çˆ¬æ¥¼æ¢¯kamacoder.com](https://kamacoder.com/problempage.php?pid=1067)

```java
package ä»£ç éšæƒ³å½•.KamaCoder.å®Œå…¨èƒŒåŒ…;

import java.util.Scanner;

/**
 * @Author: ZJX
 * @Date: 2024/10/31
 * @Description:
 */
public class w57çˆ¬æ¥¼æ¢¯è¿›é˜¶ {

    public class Main {

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            //f[i] è¡¨ç¤ºæœ‰ f[i]ä¸­æ–¹æ³•çˆ¬åˆ°ç¬¬ i å±‚æ¥¼æ¢¯
            int[] f = new int[n + 1];
            f[0] = 1;
            //f[i] ç”± f[i - x(xå±äº[1,m]å†³å®š)]
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    if (i >= j)
                        f[i] += f[i - j];
                }
            }
            System.out.println(f[n]);
        }
    }
}
```



## 1.2 æ‰“å®¶åŠ«èˆ

###é’ˆå¯¹ç´¢å¼•ä¸‹æ ‡çš„

#### I

#### II

#### III

[337. æ‰“å®¶åŠ«èˆ III - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/house-robber-iii/description/)

```java
package ä»£ç éšæƒ³å½•.åŠ¨æ€è§„åˆ’.æ‰“å®¶åŠ«èˆ;

import Common.TreeNode;

import java.util.HashMap;

/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a337æ‰“å®¶åŠ«èˆIII {
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     * int val;
     * TreeNode left;
     * TreeNode right;
     * TreeNode() {}
     * TreeNode(int val) { this.val = val; }
     * TreeNode(int val, TreeNode left, TreeNode right) {
     * this.val = val;
     * this.left = left;
     * this.right = right;
     * }
     * }
     */
    class Solution {
        HashMap<TreeNode, Integer> memo = new HashMap<>();

        public int rob(TreeNode root) {
            if (root == null)
                return 0;
            if (memo.containsKey(root))
                return memo.get(root);

            int do_it = root.val +
                    (root.left == null ? 0 : rob(root.left.left) + rob(root.left.right)) +
                    (root.right == null ? 0 : rob(root.right.left) + rob(root.right.right));
            int not_do = rob(root.left) + rob(root.right);

            int res = Math.max(do_it, not_do);
            memo.put(root, res);

            return res;
        }
    }
}
```



### é’ˆå¯¹å€¼åŸŸ

[740. åˆ é™¤å¹¶è·å¾—ç‚¹æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/delete-and-earn/description/)

```java
package Type_.åŠ¨æ€è§„åˆ’.æ‰“å®¶åŠ«èˆ;

import java.util.HashMap;
import java.util.HashSet;

/**
 * 740. åˆ é™¤å¹¶è·å¾—ç‚¹æ•°
 * https://leetcode.cn/problems/delete-and-earn/description/
 */
public class a740åˆ é™¤å¹¶è·å¾—ç‚¹æ•° {
    class Solution {
        public int deleteAndEarn(int[] nums) {
            //åˆ é™¤ æ‰€æœ‰ ç­‰äº nums[i] - 1 å’Œ nums[i] + 1 çš„å…ƒç´ ï¼Œ

            //ç›´è§‚ï¼šç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°æ¬¡æ•° -> æŸä¸ªå…ƒç´ è¢«åˆ é™¤äº†,ç›¸å½“äºè¿™ä¸ªå…ƒç´ å¯¹åº”çš„å…ƒç´ å’Œä¸èƒ½é€‰äº†
            //å°† nums[i] - 1  nums[i]  nums[i] + 1 è½¬åŒ–ä¸ºæ¨ªè½´,å°±å˜æˆäº†æ‰“å®¶åŠ«èˆé—®é¢˜
            int maxVal = 0;
            //è®¡ç®—æœ€å¤§å€¼
            for (int num : nums)
                maxVal = Math.max(maxVal, num);
            int[] sum = new int[maxVal + 1];
            //è®¡ç®— æ¯ä¸ªå…ƒç´ çš„å’Œ
            for (int num : nums)
                sum[num] += num;
            int[] f = new int[maxVal + 1];
            //f[i] è¡¨ç¤ºnums[0 - i] åˆ é™¤æŸç‚¹æ•°è·å¾—çš„æœ€å¤§å€¼ ,ç›¸å½“äºé€‰äº†f[i] ä¸èƒ½é€‰ f[i - 1] å’Œ f[i + 1];
            f[0] = sum[0];
            f[1] = Math.max(sum[0], sum[1]);
            //0 0 2 3 4
            for (int i = 2; i < f.length; i++) {
                f[i] = Math.max(f[i - 1],f[i - 2] + sum[i]);
            }
            return f[maxVal];
        }
    }
}
```



**é‡ç‚¹åœ¨äº å€¼åŸŸ->ç´¢å¼•ä¸‹æ ‡**



[3186. æ–½å’’çš„æœ€å¤§æ€»ä¼¤å®³](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/)

```java
package Type_.åŠ¨æ€è§„åˆ’.æ‰“å®¶åŠ«èˆ;

import java.util.*;
import java.util.function.BiFunction;

/**
 * @Author: ZJX
 * @Date: 2024/12/02
 * @Description:
 */
public class a3186æ–½å’’çš„æœ€å¤§æ€»ä¼¤å®³ {
    class Solution1 {
        //OOM
        public long maximumTotalDamage(int[] power) {
            HashMap<Integer, Long> record = new HashMap<>();
            int mx = 0;
            for (int v : power) {
                record.put(v, record.getOrDefault(v, 0L) + v);
                mx = Math.max(mx, v);
            }
            long[] f = new long[mx + 1];
            f[0] = record.getOrDefault(0, 0L);
            f[1] = Math.max(record.getOrDefault(0, 0L), record.getOrDefault(1, 0L));
            if (mx >= 2)
                f[2] = Math.max(record.getOrDefault(2, 0L), Math.max(record.getOrDefault(0, 0L), record.getOrDefault(1, 0L)));
            for (int i = 3; i <= mx; i++) {
                f[i] = Math.max(Math.max(f[i - 1], f[i - 2]), f[i - 3] + record.getOrDefault(i, 0L));
            }
            return f[mx];
        }
    }

    class Solution2 {
        //1,6,6,7

        //1,1,3,4
        public long maximumTotalDamage(int[] power) {
            HashMap<Integer, Integer> record = new HashMap<>();
            int mx = 0;
            for (int v : power) {
                record.put(v, record.getOrDefault(v, 0) + 1);
                mx = Math.max(mx, v);
            }
            long p0 = 0;
            long p1 = (long) record.getOrDefault(1, 0);
            long p2 = 0;
            if (mx >= 2)
                p2 = Math.max(record.getOrDefault(2, 0) * 2, Math.max(p0, p1));
            long p3 = Math.max(Math.max(p2, p1), p0 + record.getOrDefault(3, 0) * 3L);
            for (int i = 3; i <= mx; i++) {
                p3 = Math.max(Math.max(p2, p1), p0 + (long) record.getOrDefault(i, 0) * i);
                p0 = p1;
                p1 = p2;
                p2 = p3;
            }
            //p0 p1 p2 p3
            //   p0 p1 p2 p3
            return p3;
        }
    }


    class Solution3 {
        class Solution {
            public long maximumTotalDamage(int[] power) {
                Map<Integer, Integer> cnt = new HashMap<>();
                for (int x : power) {
                    //ç»Ÿè®¡æ¯ä¸ªå…ƒç´ çš„å‡ºç°æ¬¡æ•°ï¼Œè®°åˆ°å“ˆå¸Œè¡¨ cnt ä¸­ã€‚
                    cnt.merge(x, 1, Integer::sum);
                }
                int n = cnt.size();
                int[] arr = new int[n];
                int idx = 0;
                //å°†å“ˆå¸Œè¡¨çš„ key æ•´ç†åˆ°æ•°ç»„ arr ä¸­ï¼ŒæŠŠ arr æŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºæ’åºã€‚
                for (Integer x : cnt.keySet()) {
                    arr[idx++] = x;
                }
                Arrays.sort(arr);

                //arr: 1,6,7
                //arr: 1,3,4
                //å®šä¹‰f[i] è¡¨ç¤ºä»arr[0] åˆ° arr[i - 1] ä¸­é€‰æ‹©,å¯ä»¥å¾—åˆ°çš„ä¼¤å®³ä¹‹å’Œçš„æœ€å¤§å€¼
                long[] f = new long[n + 1];
                int j = 0;
                for (int i = 1; i <= n; i++) {
                    int x = arr[i - 1];
                    while (arr[j] < x - 2) {
                        j++;
                    }
                    //å¦‚æœä¸é€‰å½“å‰çš„,åˆ™f[i] = f[i - 1]
                    //å¦‚æœé€‰,åˆ™ä¼¤å®³å€¼ç­‰äº arr[i - 1] - 1 ,arr[i - 1] - 2çš„ä¸èƒ½é€‰, ä»arr[0] åˆ° arr[j - 1]ä¸­é€‰æ‹©,å¯ä»¥å¾—åˆ°çš„ä¼¤å®³çš„æœ€å¤§å€¼,å…¶ä¸­jæœ€å°çš„æ»¡è¶³arr[j] >= a[i - 1] - 2
                    f[i] = Math.max(f[i - 1], f[j] + (long) x * cnt.get(x));
                }
                return f[n];
            }
        }
    }
}
```



## 1.3æœ€å¤§å­æ•°ç»„å’Œ(æœ€å¤§å­æ®µå’Œ)

![image-20241202235055974](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/1.3-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C(%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C).png)









#äºŒ.ç½‘æ ¼å›¾DP

## 2.1åŸºç¡€



## 2.2è¿›é˜¶

[174. åœ°ä¸‹åŸæ¸¸æˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/dungeon-game/description/) - åŒºåˆ«äº 64é¢˜çš„[æœ€å°è·¯å¾„å’Œ]

è¿™é“é¢˜æ˜¯æœ‰çŠ¶æ€çš„ï¼Œéœ€è¦å€’åºDP

```java
class Solution1 {
    /**
     * è®°å¿†åŒ–æœç´¢
     */
    int[][] memo;

    public int calculateMinimumHP(int[][] dungeon) {
        int m = dungeon.length, n = dungeon[0].length;
        memo = new int[m][n];
        for (int[] e : memo) {
            //åˆå§‹åŒ–ä¸º-1,è¡¨ç¤ºæ²¡æœ‰éå†è¿‡
            Arrays.fill(e, -1);
        }
        return dfs(0, 0, dungeon);
    }

    //ä» grid[i][j] åˆ°è¾¾ç»ˆç‚¹ï¼ˆå³ä¸‹è§’ï¼‰æ‰€éœ€çš„æœ€å°‘åˆå§‹ç”Ÿå‘½å€¼æ˜¯ dfs(grid, i, j)
    private int dfs(int x, int y, int[][] g) {
        int m = g.length, n = g[0].length;

        //base case
        if (x == m - 1 && y == n - 1) {
            return Math.max(1, 1 - g[x][y]);
        }
        if (x == m || y == n)
            return Integer.MAX_VALUE;
        if (memo[x][y] != -1)
            return memo[x][y];
        int res = Math.max(
                Math.min(dfs(x + 1, y, g), dfs(x, y + 1, g)) - g[x][y],
                1);
        return memo[x][y] = res;
    }
}

class Solution2 {
    //è¿™é“é¢˜çš„dpæ˜¯å€’åºçš„ï¼Œè¿™ç‚¹å¾ˆé‡è¦ï¼Œä¸ºä»€ä¹ˆä¸èƒ½åƒã€æœ€å°è·¯å¾„å’Œã€‘ä¸€æ ·æ˜¯æ­£åºçš„ï¼Ÿå› ä¸ºã€æœ€å°è·¯å¾„å’Œã€‘æ˜¯æ— çŠ¶æ€çš„ï¼Œä½ ä¼šå‘ç°ã€æœ€å°è·¯å¾„å’Œã€‘å€’åºdpä¹Ÿæ˜¯å¯ä»¥çš„
    //è¿™é“é¢˜ç”±äºæœ‰â€œåŠ è¡€â€çš„è¿‡ç¨‹ï¼Œåªèƒ½ä¾èµ–åé¢çš„å€¼åˆ¤æ–­éœ€è¦çš„è¡€é‡ã€‚æ‰€ä»¥è¿™é‡Œçš„dp[i][j]è¡¨è¾¾çš„æ„æ€æ˜¯ï¼šâ€œä»ï¼ˆiï¼Œjï¼‰å‡ºå‘ï¼Œåˆ°è¾¾ç»ˆç‚¹éœ€è¦æœ€å°‘çš„è¡€é‡â€ã€‚
    //å› æ­¤ï¼Œæ­£åºçš„å«ä¹‰ä¸ºâ€œä»èµ·ç‚¹å‡ºå‘ï¼Œåˆ°è¾¾ä½ç½®ï¼ˆiï¼Œjï¼‰æ‰€éœ€è¦çš„æœ€å°‘è¡€é‡â€ï¼›å€’åºçš„å«ä¹‰æ˜¯â€œä»ï¼ˆiï¼Œjï¼‰å‡ºå‘ï¼Œåˆ°è¾¾ç»ˆç‚¹éœ€è¦æœ€å°‘çš„è¡€é‡â€ã€‚åˆå§‹è¡€é‡æœ¬æ¥å°±æ˜¯è¦æ±‚çš„ï¼Œæ‰€ä»¥åªèƒ½å€’åºdp
    class Solution {
        public int calculateMinimumHP(int[][] dungeon) {
            int m = dungeon.length, n = dungeon[0].length;
            int[][] f = new int[m][n];
            //f[i][j] è¡¨ç¤ºï¼š ä» i,j å‡ºå‘,åˆ°è¾¾ç»ˆç‚¹æ‰€éœ€è¦çš„æœ€å°‘çš„è¡€é‡

            //base case
            f[m - 1][n - 1] = Math.max(1, 1 - dungeon[m - 1][n - 1]);
            for (int i = m - 2; i >= 0; i--)
                f[i][n - 1] = Math.max(1, f[i + 1][n - 1] - dungeon[i][n - 1]);

            for (int j = n - 2; j >= 0; j--)
                f[m - 1][j] = Math.max(1, f[m - 1][j + 1] - dungeon[m - 1][j]);

            for (int i = m - 2; i >= 0; i--) {
                for (int j = n - 2; j >= 0; j--) {
                    f[i][j] = Math.max(1, Math.min(f[i + 1][j], f[i][j + 1]) - dungeon[i][j]);
                }
            }
            return f[0][0];
        }
    }
}

class Solution3 {
    //è¿™é“é¢˜çš„dpæ˜¯å€’åºçš„ï¼Œè¿™ç‚¹å¾ˆé‡è¦ï¼Œä¸ºä»€ä¹ˆä¸èƒ½åƒã€æœ€å°è·¯å¾„å’Œã€‘ä¸€æ ·æ˜¯æ­£åºçš„ï¼Ÿå› ä¸ºã€æœ€å°è·¯å¾„å’Œã€‘æ˜¯æ— çŠ¶æ€çš„ï¼Œä½ ä¼šå‘ç°ã€æœ€å°è·¯å¾„å’Œã€‘å€’åºdpä¹Ÿæ˜¯å¯ä»¥çš„
    //è¿™é“é¢˜ç”±äºæœ‰â€œåŠ è¡€â€çš„è¿‡ç¨‹ï¼Œåªèƒ½ä¾èµ–åé¢çš„å€¼åˆ¤æ–­éœ€è¦çš„è¡€é‡ã€‚æ‰€ä»¥è¿™é‡Œçš„dp[i][j]è¡¨è¾¾çš„æ„æ€æ˜¯ï¼šâ€œä»ï¼ˆiï¼Œjï¼‰å‡ºå‘ï¼Œåˆ°è¾¾ç»ˆç‚¹éœ€è¦æœ€å°‘çš„è¡€é‡â€ã€‚
    //å› æ­¤ï¼Œæ­£åºçš„å«ä¹‰ä¸ºâ€œä»èµ·ç‚¹å‡ºå‘ï¼Œåˆ°è¾¾ä½ç½®ï¼ˆiï¼Œjï¼‰æ‰€éœ€è¦çš„æœ€å°‘è¡€é‡â€ï¼›å€’åºçš„å«ä¹‰æ˜¯â€œä»ï¼ˆiï¼Œjï¼‰å‡ºå‘ï¼Œåˆ°è¾¾ç»ˆç‚¹éœ€è¦æœ€å°‘çš„è¡€é‡â€ã€‚åˆå§‹è¡€é‡æœ¬æ¥å°±æ˜¯è¦æ±‚çš„ï¼Œæ‰€ä»¥åªèƒ½å€’åºdp
    class Solution {
        public int calculateMinimumHP(int[][] dungeon) {
            int m = dungeon.length, n = dungeon[0].length;
            int[][] f = new int[m + 1][n + 1];
            //f[i][j] è¡¨ç¤ºï¼š ä» i,j å‡ºå‘,åˆ°è¾¾ç»ˆç‚¹æ‰€éœ€è¦çš„æœ€å°‘çš„è¡€é‡
            //base case
            for (int[] row : f) {
                Arrays.fill(row, Integer.MAX_VALUE);
            }
            f[m][n - 1] = f[m - 1][n] = 1;
            for (int i = m - 1; i >= 0; i--) {
                for (int j = n - 1; j >= 0; j--) {
                    f[i][j] = Math.max(1, Math.min(f[i + 1][j], f[i][j + 1]) - dungeon[i][j]);
                }
            }
            return f[0][0];
        }
    }
}
```



### ç½‘æ ¼å›¾ä¸­çš„é€’å¢è·¯å¾„æ•°ç›®/æœ€å¤§é•¿åº¦

[2328. ç½‘æ ¼å›¾ä¸­é€’å¢è·¯å¾„çš„æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/)

[329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)



2328è§£æ³•ï¼š

```java
package Type_.åŠ¨æ€è§„åˆ’.äºŒ_ç½‘æ ¼å›¾DP.è¿›é˜¶;

/**
 * @Author: ZJX
 * @Date: 2024/12/03
 * @Description:
 */
public class a2328ç½‘æ ¼å›¾ä¸­é€’å¢è·¯å¾„çš„æ•°ç›® {
    class Solution {
        public static final int mod = (int) 1e9 + 7;
        int[][] f;
        public final static int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        public int countPaths(int[][] s) {
            int m = s.length, n = s[0].length;
            f = new int[m][n];
            int res = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    res = (res + dfs(i, j, s)) % mod;
                }
            }
            return res;
        }

        private int dfs(int x, int y, int[][] s) {
            //æ‰¾åˆ°ä»¥x,yä¸ºèµ·å§‹ç‚¹çš„LIS
            if (f[x][y] != 0)
                return f[x][y];

            int res = 1;
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                //æŒ‡æ˜æ–¹å‘ å¾€ åˆæ³• ä¸” å¤§äºå½“å‰å€¼çš„æ–¹å‘ç§»åŠ¨
                if (valid(nx, ny, s) && s[nx][ny] > s[x][y]) {
                    res = (res % mod + dfs(nx, ny, s) % mod) % mod;
                }
            }
            return f[x][y] = res;
        }

        private boolean valid(int x, int y, int[][] s) {

            int m = s.length, n = s[0].length;
            //ä¸åˆæ³•
            return x >= 0 && x < m && y >= 0 && y < n;
        }
    }
}
```







### ä¸‰ç»´DP

éœ€è¦é¢å¤–ä¿å­˜çŠ¶æ€

[688. éª‘å£«åœ¨æ£‹ç›˜ä¸Šçš„æ¦‚ç‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/knight-probability-in-chessboard/description/)









# èƒŒåŒ…é—®é¢˜

## 0-1èƒŒåŒ…

### åŸºæœ¬



![image-20240604151046229](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-1.png)

#### Code

```java
class Solution1 {
    /**
     * ç»™ä½ ä¸€ä¸ªå¯è£…è½½é‡é‡ä¸º capacity çš„èƒŒåŒ…å’Œ n ä¸ªç‰©å“,æ¯ä¸ªç‰©å“æœ‰é‡é‡å’Œä»·å€¼ä¸¤ä¸ªå±æ€§ã€‚
     * å…¶ä¸­ç¬¬ i ä¸ªç‰©å“çš„é‡é‡ä¸º w[i] ,ä»·å€¼ä¸º v[i] ,ç°åœ¨è®©ä½ ç”¨è¿™ä¸ªèƒŒåŒ…è£…ç‰©å“,æœ€å¤šèƒ½è£…çš„ä»·å€¼æ˜¯å¤šå°‘?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        ç¬¬iä¸ªç‰©å“çš„ä»·å€¼
     * @param w        ç¬¬iä¸ªç‰©å“çš„ä½“ç§¯
     * @param capacity èƒŒåŒ…å®¹é‡
     * @return åœ¨ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡çš„æƒ…å†µä¸‹ï¼ŒèƒŒåŒ…ä¸­æ”¾å…¥çš„ç‰©å“çš„æœ€å¤§ä»·å€¼
     */

    int[] v;

    int[] w;

    int capacity;

    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        this.v = v;
        this.w = w;
        this.capacity = capacity;

        return dfs(capacity, v.length - 1);
    }

    /**
     * @param capacity å½“å‰èƒŒåŒ…çš„å®¹é‡
     * @param i        å½“å‰æ˜¯ç¬¬å‡ ä¸ªç‰©å“
     * @return åœ¨ä¸è¶…è¿‡capacityå®¹é‡çš„æƒ…å†µä¸‹, åœ¨å‰iä¸ªç‰©å“ä¸­åŠ å…¥äº†èƒŒåŒ…çš„ç‰©å“çš„æœ€å¤§ä»·å€¼
     */

    private int dfs(int capacity, int i) {
        if (i < 0)
            return 0;
        if (capacity < w[i])
            return dfs(capacity, i - 1);
        //å½“å‰æ“ä½œ ï¼š æšä¸¾å½“å‰ç‰©å“ï¼Œé€‰/ä¸é€‰
        //é€‰:ç©ºå‡ºç‰©å“w[i]çš„é‡é‡å,åœ¨å®¹é‡ä¸ºcapacity - w[i],ä»å‰i - 1ä¸ªç‰©å“ä¸­å¾—åˆ°çš„æœ€å¤§ä»·å€¼å’Œ
        //ä¸é€‰:åœ¨å®¹é‡ä¸ºcapacity,ä»å‰i - 1ä¸ªç‰©å“ä¸­å¾—åˆ°çš„æœ€å¤§ä»·å€¼å’Œ
        return Math.max(dfs(capacity - w[i], i - 1) + v[i], dfs(capacity, i - 1));
    }
}


class Solution2 {
    /**
     * ç»™ä½ ä¸€ä¸ªå¯è£…è½½é‡é‡ä¸º capacity çš„èƒŒåŒ…å’Œ n ä¸ªç‰©å“,æ¯ä¸ªç‰©å“æœ‰é‡é‡å’Œä»·å€¼ä¸¤ä¸ªå±æ€§ã€‚
     * å…¶ä¸­ç¬¬ i ä¸ªç‰©å“çš„é‡é‡ä¸º w[i] ,ä»·å€¼ä¸º v[i] ,ç°åœ¨è®©ä½ ç”¨è¿™ä¸ªèƒŒåŒ…è£…ç‰©å“,æœ€å¤šèƒ½è£…çš„ä»·å€¼æ˜¯å¤šå°‘?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        ç¬¬iä¸ªç‰©å“çš„ä»·å€¼
     * @param w        ç¬¬iä¸ªç‰©å“çš„ä½“ç§¯
     * @param capacity èƒŒåŒ…å®¹é‡
     * @return åœ¨ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡çš„æƒ…å†µä¸‹ï¼ŒèƒŒåŒ…ä¸­æ”¾å…¥çš„ç‰©å“çš„æœ€å¤§ä»·å€¼
     */
    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        int n = v.length;
        int[][] f = new int[n + 1][capacity + 1];
        //å®šä¹‰ï¼šf[i][c] çš„å®šä¹‰å¦‚ä¸‹ï¼šå¯¹äºå‰ i ä¸ªç‰©å“ï¼Œå½“å‰èƒŒåŒ…çš„å®¹é‡ä¸º cï¼Œè¿™ç§æƒ…å†µä¸‹å¯ä»¥è£…çš„æœ€å¤§ä»·å€¼æ˜¯ dp[i][c]ã€‚
        //æ¯”å¦‚è¯´ï¼Œå¦‚æœ f[3][5] = 6ï¼Œå…¶å«ä¹‰ä¸ºï¼šå¯¹äºç»™å®šçš„ä¸€ç³»åˆ—ç‰©å“ä¸­ï¼Œè‹¥åªå¯¹å‰ 3 ä¸ªç‰©å“è¿›è¡Œé€‰æ‹©ï¼Œå½“èƒŒåŒ…å®¹é‡ä¸º 5 æ—¶ï¼Œæœ€å¤šå¯ä»¥è£…ä¸‹çš„ä»·å€¼ä¸º 6ã€‚
        //æ³¨æ„è¿™é‡Œçš„ä¸‹æ ‡iä»(1)å¼€å§‹,è¡¨ç¤ºä»å‰(1)ä¸ªç‰©å“å¼€å§‹å–ã€‚
        for (int i = 1; i <= n; i++) {
            for (int c = w[i]; c <= capacity; c++) {
                //å¦‚æœæŠŠè¿™ç¬¬ i ä¸ªç‰©å“è£…å…¥äº†èƒŒåŒ…ï¼Œé‚£ä¹ˆç¬¬ i ä¸ªç‰©å“çš„ä»·å€¼ val[i-1] è‚¯å®šå°±åˆ°æ‰‹äº†
                //æ¥ä¸‹æ¥å°±è¦åœ¨å‰©ä½™å®¹é‡ c - w[i-1] çš„é™åˆ¶ä¸‹ï¼Œåœ¨å‰ i - 1 ä¸ªç‰©å“ä¸­æŒ‘é€‰ï¼Œæ±‚æœ€å¤§ä»·å€¼ï¼Œå³ f[i-1][c - w[i-1]]ã€‚
                //f[i][c] åº”è¯¥ç­‰äº  f[i-1][c - w[i-1]] + v[i-1]ã€‚
                //å¦‚æœæ²¡æœ‰æŠŠè¿™ç¬¬ i ä¸ªç‰©å“è£…å…¥èƒŒåŒ…ï¼Œé‚£ä¹ˆå¾ˆæ˜¾ç„¶ï¼Œæœ€å¤§ä»·å€¼ f[i][c] åº”è¯¥ç­‰äº f[i-1][w]ï¼Œç»§æ‰¿ä¹‹å‰çš„ç»“æœã€‚
                f[i][c] = Math.max(f[i - 1][c - w[i - 1]] + v[i - 1],f[i - 1][c]);
            }
        }
        return f[n][capacity];
    }
}


```





### å¸¸è§å˜å½¢

![image-20240604153612813](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-%E5%B8%B8%E8%A7%81%E5%8F%98%E5%BD%A2.png)



#### 1. æ°å¥½æ»¡è¶³çš„æ–¹æ¡ˆæ•°-ç›®æ ‡å’Œ

[494. ç›®æ ‡å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/target-sum/description/)

```java
/**
 * 494. ç›®æ ‡å’Œ
 * https://leetcode.cn/problems/target-sum/description/
 */

public class a494ç›®æ ‡å’Œ {
    class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x , sum - x
            //x - sum + x = target
            //x = (sum + target) / 2
            
            int sum = 0;
            int n = nums.length;
            for (int num : nums)
                sum += num;
            int target = sum + t;
            if (target < 0 || target % 2 != 0)
                return 0;
            target >>= 1;
            //f[i][w] è¡¨ç¤ºä»å‰ i ä¸ªæ•°ä¸­é€‰å‡ºå‡ ä¸ªæ•°,å…¶å’Œä¸º w çš„æ–¹æ³•æ•°
            int[][] f = new int[n + 1][target + 1];
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= target; w++) {
                    //ç¬¬iä¸ªæ•°é€‰ï¼šå­é—®é¢˜å˜ä¸ºä»å‰i - 1ä¸ªæ•°ä¸­é€‰å‡ºå‡ ä¸ªæ•°,å…¶å’Œä¸ºw-nums[i - 1]çš„æ–¹æ³•æ•°
                    //ç¬¬iä¸ªæ•°ä¸é€‰:å­é—®é¢˜å˜ä¸ºä»å‰i - 1ä¸ªæ•°ä¸­é€‰å‡ºå‡ ä¸ªæ•°,å…¶å’Œä¸ºwçš„æ–¹æ³•æ•°
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                    else
                        f[i][w] = f[i - 1][w - nums[i - 1]] + f[i - 1][w];
                }
            }
            return f[n][target];
        }
    }
}
```





#### 2. æ˜¯å¦èƒ½æ»¡è¶³-åˆ†å‰²ç­‰å’Œå­é›†

[416. åˆ†å‰²ç­‰å’Œå­é›† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

```java
class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x + y = sum;
            //x - y = t;
            //x = (sum + t) / 2;
            int sum = 0;
            for (int num : nums) {
                sum += num;
            }
            int s = sum + t, n = nums.length;
            if (s < 0 || (s & 1) != 0)
                return 0;
            s >>= 1;
            int[][] f = new int[n + 1][s + 1];
            //base case
            //å®šä¹‰ï¼šf[i][w] çš„å®šä¹‰å¦‚ä¸‹ï¼šå¯¹äºå‰ i ä¸ªæ•°ï¼Œæ°ä¸ºå¥½æ»¡è¶³å’Œä¸ºw çš„æ–¹æ¡ˆæ•°ä¸º f[i][w]ã€‚
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= s; w++) {
                    //è‚¯å®šä¸èƒ½é€‰å½“å‰çš„æ•°
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                        //å¯ä»¥é€‰,è€ƒè™‘ä¸¤ç§æƒ…å†µï¼Œä¸é€‰ / é€‰
                    else
                        f[i][w] = f[i - 1][w] + f[i - 1][w - nums[i - 1]];
                }
            }
            return f[n][s];
        }
    }
```

- ç±»ä¼¼é¢˜ç›® [1049. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/last-stone-weight-ii/description/)

  > ```java
  >     class Solution {
  >         public int lastStoneWeightII(int[] stones) {
  >             //æ€è·¯: å°±æ˜¯å°½é‡è®©çŸ³å¤´åˆ†æˆé‡é‡ç›¸åŒçš„ä¸¤å †ï¼Œç›¸æ’ä¹‹åå‰©ä¸‹çš„çŸ³å¤´æœ€å°ï¼Œè¿™æ ·å°±åŒ–è§£æˆ01èƒŒåŒ…é—®é¢˜äº†ã€‚
  >             //å³å˜æˆ ä» stonesä¸­ é€‰ nä¸ª çŸ³å¤´ï¼Œä½¿å¾—å…¶åœ¨é‡é‡ä¸è¶…è¿‡tçš„æƒ…å†µä¸‹ï¼Œå…¶é‡é‡æœ€å¤§ä¸ºt ã€‚å³èƒŒåŒ…æ‰€è£…çš„ç‰©å“çš„é‡é‡å’Œä»·å€¼ç›¸ç­‰ã€‚
  >             //ç”±äºt < s / 2,æ‰€ä»¥ç»“æœä¸º (s - f[n][t]) - f[n][t]
  >             int s = 0, n = stones.length;
  >             for (int w : stones) {
  >                 s += w;
  >             }
  >             int t = s >> 1;
  >             int[][] f = new int[n + 1][t + 1];
  >             for (int i = 1; i <= n; i++) {
  >                 for (int j = 1; j <= t; j++) {
  >                     if (j >= stones[i - 1])
  >                         f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - stones[i - 1]] + stones[i - 1]);
  >                     else
  >                         f[i][j] = f[i - 1][j];
  >                 }
  >             }
  >             return s - f[n][t] * 2;
  >         }
  >     }
  > ```
  >
  > 



[3180. æ‰§è¡Œæ“ä½œå¯è·å¾—çš„æœ€å¤§æ€»å¥–åŠ± I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/description/)







## å®Œå…¨èƒŒåŒ…

### 1-æ»¡è¶³..çš„ä¸ªæ•°



### 2.æ˜¯å¦æ»¡è¶³...

[139. å•è¯æ‹†åˆ† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/word-break/description/)

```java
package ä»£ç éšæƒ³å½•.åŠ¨æ€è§„åˆ’.èƒŒåŒ…é—®é¢˜.å®Œå…¨èƒŒåŒ…;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a139å•è¯æ‹†åˆ† {
    class Solution {
        public boolean wordBreak(String s, List<String> wordDict) {
            int n = s.length();
            boolean[] f = new boolean[n + 1];
            Arrays.fill(f, false);
            f[0] = true;

            for (int i = 1; i <= n; i++) {
                for (String sub : wordDict) {
                    int m = sub.length();
                    if (i < m)
                        continue;
                    String cur = s.substring(i - m, i);
                    if (cur.equals(sub))
                        f[i] = f[i] || f[i - m];
                }
            }
            return f[n];
        }
    }
}
```





#å››.çº¿æ€§DP



###4.1æœ€é•¿å…¬å…±å­åºåˆ—(LCS)

#### Hard.115.ä¸åŒçš„å­åºåˆ—

```java
package Type_.åŠ¨æ€è§„åˆ’.ç»å…¸çº¿æ€§DP.æœ€é•¿å…¬å…±å­åºåˆ—LCS;

/**
 * 115. ä¸åŒçš„å­åºåˆ—
 * https://leetcode.cn/problems/distinct-subsequences/description/
 * 2024-6-17
 */
public class a115ä¸åŒçš„å­åºåˆ— {
    class Solution {
        static final int MOD = (int) 1e9 + 7;

        public int numDistinct(String s, String t) {
            int m = s.length(), n = t.length();
            if (m < n)
                return 0;
            int[][] f = new int[m + 1][n + 1];
            //f[i][j]  å®šä¹‰ f[i][j] ä¸ºè€ƒè™‘ s ä¸­ [0~i - 1] ä¸ªå­—ç¬¦ï¼Œt ä¸­ [0~j - 1] ä¸ªå­—ç¬¦çš„åŒ¹é…ä¸ªæ•°ã€‚
            //base case
            for (int i = 0; i <= m; i++)
                f[i][0] = 1;

            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    //ä¸¤ç§å†³ç­–
                    //1.ä¸è®©s[i]å‚ä¸åŒ¹é… åˆ™ f[i][j] = f[i - 1][j]
                    f[i][j] = f[i - 1][j];
                    //2.è®©s[i]å‚ä¸åŒ¹é…, åˆ™è¦æ±‚s[i] == t[j]
                    //s[i] = t[j]
                    if(s.charAt(i - 1) == t.charAt(j - 1)){
                        f[i][j] += f[i - 1][j - 1];
                    }
                }
            }
            return f[m][n];
        }
    }
}

```

> æ€»ç»“
> å…³äºå­—ç¬¦ä¸²åŒ¹é…ï¼Œé€šå¸¸æœ‰ä¸¤ç§ï¼ˆä½ ä¹Ÿå¯ä»¥ç†è§£ä¸ºä¸€ç§ï¼‰é€šç”¨çš„çŠ¶æ€å®šä¹‰ï¼š
>
> ```bash
> 1. f[i][j] è¡¨ç¤ºç¬¬ä¸€ä¸ªå­—ç¬¦sä¸­[0~i - 1]ä¸tä¸­[0~j - 1]çš„åŒ¹é…ç»“æœ
> 
> 2. f[i][j] è¡¨ç¤ºç¬¬ä¸€ä¸ªå­—ç¬¦sä¸­[0~i - 1]ä¸tä¸­[0~j - 1] ä¸” æœ€åä¸€ä¸ªå­—ç¬¦ä¸²ä¸ºt[j] çš„åŒ¹é…ç»“æœ
> ```
>
> 
>
> ä½œè€…ï¼šå®«æ°´ä¸‰å¶



###4.2æœ€é•¿é€’å¢å­åºåˆ—(LIS)

åšæ³•æœ‰å¾ˆå¤šï¼š

- æšä¸¾é€‰å“ªä¸ªï¼ˆè§è®²è§£ï¼‰ã€‚
- è´ªå¿ƒ+äºŒåˆ†ï¼ˆè§è®²è§£ï¼‰ã€‚
- è®¡ç®— ğ‘ å’ŒæŠŠ a æ’åºåçš„æ•°ç»„ sortedA çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚
- æ•°æ®ç»“æ„ä¼˜åŒ–ï¼ˆè§ 2407 é¢˜ï¼‰ã€‚

```java
package Type_.åŠ¨æ€è§„åˆ’.ç»å…¸çº¿æ€§DP.æœ€é•¿é€’å¢å­åºåˆ—LIS;

import java.util.Arrays;

/**
 * 300. æœ€é•¿é€’å¢å­åºåˆ—
 * https://leetcode.cn/problems/longest-increasing-subsequence/description/
 * 2024-6-17
 */
public class a300æœ€é•¿é€’å¢å­åºåˆ— {
    class Solution {
        public int lengthOfLIS(int[] nums) {
            int n = nums.length;
            int[] f = new int[n];
            //f[i] è¡¨ç¤ºä»¥nums[0~i]çš„å­åºåˆ—ä¸”ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
            Arrays.fill(f, 1);
            int ret = 1;
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j])
                        f[i] = Math.max(f[i], f[j] + 1);
                }
                ret = Math.max(ret, f[i]);
            }
            System.out.println(Arrays.toString(f));
            return ret;
        }
    }
}

```



ä¼˜åŒ–ï¼š

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        //g[i] çš„ å®šä¹‰ä¸º : é•¿åº¦ä¸º i + 1 çš„ é€’å¢å­åºåˆ—çš„ æœ«å°¾å…ƒç´ çš„æœ€å°å€¼
        List<Integer> g = new ArrayList<>();
        for (int x : nums) {
            int j = lowerBound(g, x);
            if (j == g.size())
                g.add(x);
            else
                g.set(j, x);
        }
        return g.size();
    }


    //å¤§äºç­‰äº target çš„æœ€å°å…ƒç´ ä¸‹æ ‡
    private int lowerBound(List<Integer> g, int target) {
        int left = 0, right = g.size();
        while (left < right) {
            int mid = (right - left) / 2 + left;
            //[left,mid) mid [mid,right)
            if (g.get(mid) >= target)
                right = mid;
            else
                left = mid + 1;
        }
        return right;
    }
}
```





LISçš„ä¸ªæ•°

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        int[] f = new int[n], g = new int[n];
        //f[i] è¡¨ç¤ºä»¥nums[0~i]çš„å­åºåˆ—ä¸”ä»¥nums[i]ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
        //g[i] ä¸ºè€ƒè™‘ä»¥ nums[i] ç»“å°¾çš„æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°ã€‚
        int mx = 1;
        for (int i = 0; i < n; i++) {
            f[i] = g[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    //æ»¡è¶³ f[i]<f[j]+1ï¼šè¯´æ˜ f[i] ä¼šè¢« f[j]+1 ç›´æ¥æ›´æ–°ï¼Œæ­¤æ—¶åŒæ­¥ç›´æ¥æ›´æ–° g[i]=g[j] å³å¯ï¼›

                    //ç›¸å½“äº ç¬¬ä¸€æ¬¡å¾—åˆ°f[i]
                    if (f[i] < f[j] + 1) {
                        f[i] = f[j] + 1;
                        g[i] = g[j];

                    } else if (f[i] == f[j] + 1) {
                        //æ»¡è¶³ f[i]=f[j]+1ï¼šè¯´æ˜æ‰¾åˆ°äº†ä¸€ä¸ªæ–°çš„ç¬¦åˆæ¡ä»¶çš„å‰é©±ï¼Œæ­¤æ—¶å°†å€¼ç»§ç»­ç´¯åŠ åˆ°æ–¹æ¡ˆæ•°å½“ä¸­ï¼Œå³æœ‰ g[i]+=g[j]ã€‚
                        //ç›¸å½“äº å¹¶éç¬¬ä¸€æ¬¡å¾—åˆ°f[i]
                        g[i] += g[j];
                    }
                }
            }
            mx = Math.max(mx, f[i]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (f[i] == mx)
                ans += g[i];
        }
        return ans;
    }
}
```









# ç»å…¸







## è‚¡ç¥¨ä¹°å–

**æ¯å¤©éƒ½æœ‰ä¸‰ç§ã€Œé€‰æ‹©ã€**ï¼šä¹°å…¥ã€å–å‡ºã€æ— æ“ä½œï¼Œæˆ‘ä»¬ç”¨ `buy`, `sell`, `rest` è¡¨ç¤ºè¿™ä¸‰ç§é€‰æ‹©ã€‚

**æˆ‘ä»¬æŠŠä¸€æ¬¡ä¹°å…¥å’Œä¸€æ¬¡å–å‡ºå®šä¹‰ä¸ºä¸€æ¬¡ã€Œäº¤æ˜“ã€**ã€‚



**è¿™ä¸ªé—®é¢˜çš„ã€ŒçŠ¶æ€ã€æœ‰ä¸‰ä¸ª**ï¼Œç¬¬ä¸€ä¸ªæ˜¯å¤©æ•°ï¼Œç¬¬äºŒä¸ªæ˜¯å…è®¸äº¤æ˜“çš„æœ€å¤§æ¬¡æ•°ï¼Œç¬¬ä¸‰ä¸ªæ˜¯å½“å‰çš„æŒæœ‰çŠ¶æ€ï¼ˆå³ä¹‹å‰è¯´çš„ `rest` çš„çŠ¶æ€ï¼Œæˆ‘ä»¬ä¸å¦¨ç”¨ 1 è¡¨ç¤ºæŒæœ‰ï¼Œ0 è¡¨ç¤ºæ²¡æœ‰æŒæœ‰ï¼‰ã€‚



ç„¶åæˆ‘ä»¬ç”¨ä¸€ä¸ªä¸‰ç»´æ•°ç»„å°±å¯ä»¥è£…ä¸‹è¿™å‡ ç§çŠ¶æ€çš„å…¨éƒ¨ç»„åˆï¼š

```python
dp[i][k][0 or 1]
0 <= i <= n , 1 <= k <= K
n ä¸ºç¬¬å‡ å¤©ï¼Œå¤§ K ä¸ºäº¤æ˜“æ•°çš„ä¸Šé™ï¼Œ0 å’Œ 1 ä»£è¡¨æ˜¯å¦æŒæœ‰è‚¡ç¥¨ã€‚
æ­¤é—®é¢˜å…± n Ã— K Ã— 2 ç§çŠ¶æ€ï¼Œå…¨éƒ¨ç©·ä¸¾å°±èƒ½æå®šã€‚

for 1 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

`dp[3][2][1]` çš„å«ä¹‰å°±æ˜¯ï¼šä»Šå¤©æ˜¯ç¬¬ä¸‰å¤©ï¼Œæˆ‘ç°åœ¨æ‰‹ä¸ŠæŒæœ‰ç€è‚¡ç¥¨ï¼Œè‡³ä»Šæœ€å¤šè¿›è¡Œ 2 æ¬¡äº¤æ˜“ã€‚å†æ¯”å¦‚ `dp[2][3][0]` çš„å«ä¹‰ï¼šä»Šå¤©æ˜¯ç¬¬äºŒå¤©ï¼Œæˆ‘ç°åœ¨æ‰‹ä¸Šæ²¡æœ‰æŒæœ‰è‚¡ç¥¨ï¼Œè‡³ä»Šæœ€å¤šè¿›è¡Œ 3 æ¬¡äº¤æ˜“ã€‚



æ³¨æ„ `k` çš„é™åˆ¶ï¼Œåœ¨é€‰æ‹© `buy` çš„æ—¶å€™ç›¸å½“äºå¼€å¯äº†ä¸€æ¬¡äº¤æ˜“ï¼Œé‚£ä¹ˆå¯¹äºæ˜¨å¤©æ¥è¯´ï¼Œäº¤æ˜“æ¬¡æ•°çš„ä¸Šé™ `k` åº”è¯¥å‡å° 1ã€‚

å› ä¸ºäº¤æ˜“æ˜¯ä» `buy` å¼€å§‹ï¼Œå¦‚æœ `buy` çš„é€‰æ‹©ä¸æ”¹å˜äº¤æ˜“æ¬¡æ•° `k` çš„è¯ï¼Œä¼šå‡ºç°äº¤æ˜“æ¬¡æ•°è¶…å‡ºé™åˆ¶çš„çš„é”™è¯¯ã€‚



```java
f[i][k][0] = Math.max(f[i - 1][k][1] + prices[i - 1], f[i - 1][k][0]);
//f[i][k][0] = Math.max(         ä»Šå¤©é€‰æ‹©å–,             ä»Šå¤©ä¼‘æ¯,ä¸å–)
```

è§£é‡Šï¼šä»Šå¤©æˆ‘æ²¡æœ‰æŒæœ‰è‚¡ç¥¨ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼Œæˆ‘ä»è¿™ä¸¤ç§å¯èƒ½ä¸­æ±‚æœ€å¤§åˆ©æ¶¦ï¼š

1. æˆ‘æ˜¨å¤©æŒæœ‰è‚¡ç¥¨ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kï¼›ä½†æ˜¯ä»Šå¤©æˆ‘ sell äº†ï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©æ²¡æœ‰æŒæœ‰è‚¡ç¥¨äº†ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¾ç„¶ä¸º kã€‚
2. æˆ‘æ˜¨å¤©å°±æ²¡æœ‰æŒæœ‰ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kï¼›ç„¶åæˆ‘ä»Šå¤©é€‰æ‹© restï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©è¿˜æ˜¯æ²¡æœ‰æŒæœ‰ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¾ç„¶ä¸º kã€‚



```java
f[i][k][1] = Math.max(f[i - 1][k - 1][0] - prices[i - 1], f[i - 1][k][1]);
//f[i][k][1] = Math.max(         ä»Šå¤©é€‰æ‹©ä¹°,             ä»Šå¤©ä¼‘æ¯,ä¸ä¹°)
```

è§£é‡Šï¼šä»Šå¤©æˆ‘æŒæœ‰è‚¡ç¥¨ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼Œæˆ‘ä»è¿™ä¸¤ç§å¯èƒ½ä¸­æ±‚æœ€å¤§åˆ©æ¶¦ï¼š

1ã€æˆ‘æ˜¨å¤©å°±æ²¡æœ‰æŒæœ‰ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º k - 1ï¼›ç„¶åæˆ‘ä»Šå¤©é€‰æ‹© buy ï¼Œæ‰€ä»¥ä»Šå¤©æˆ‘å°±æŒæœ‰è‚¡ç¥¨äº†ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kã€‚

2. æˆ‘æ˜¨å¤©æŒæœ‰è‚¡ç¥¨ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kï¼›ä½†æ˜¯ä»Šå¤©æˆ‘ rest äº†ï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©è¿˜æŒæœ‰ç€è‚¡ç¥¨ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¾ç„¶ä¸º kã€‚



base case:

```java
//f[0][...][0] = 0;
//å› ä¸º i æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥ i = 0 æ„å‘³ç€è¿˜æ²¡æœ‰å¼€å§‹ï¼Œè¿™æ—¶å€™çš„åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚

//f[0][...][1] = Integer.MIN_VALUE;
//è¿˜æ²¡å¼€å§‹çš„æ—¶å€™ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚
for (int k = 0; k <= K; k++) {
    f[0][k][1] = Integer.MIN_VALUE;
}

//f[][0][0] = 0;
//å› ä¸º k æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥ k = 0 æ„å‘³ç€æ ¹æœ¬ä¸å…è®¸äº¤æ˜“ï¼Œè¿™æ—¶å€™åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚
//f[][0][1] = Integer.MIN_VALUE;
//ä¸å…è®¸äº¤æ˜“çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚
for (int i = 0; i <= n; i++) {
    f[i][0][1] = Integer.MIN_VALUE;
}
```

### [188. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº IV - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

```java
/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a188ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºIV {
    class Solution {
        public int maxProfit(int K, int[] prices) {
            int n = prices.length;
            int[][][] f = new int[n + 1][K + 1][2];

            //base case
            //f[0][...][0] = 0;
            //å› ä¸º i æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥ i = 0 æ„å‘³ç€è¿˜æ²¡æœ‰å¼€å§‹ï¼Œè¿™æ—¶å€™çš„åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚

            //f[0][...][1] = Integer.MIN_VALUE;
            //è¿˜æ²¡å¼€å§‹çš„æ—¶å€™ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚
            for (int k = 0; k <= K; k++) {
                f[0][k][1] = Integer.MIN_VALUE;
            }

            //f[][0][0] = 0;
            //å› ä¸º k æ˜¯ä» 1 å¼€å§‹çš„ï¼Œæ‰€ä»¥ k = 0 æ„å‘³ç€æ ¹æœ¬ä¸å…è®¸äº¤æ˜“ï¼Œè¿™æ—¶å€™åˆ©æ¶¦å½“ç„¶æ˜¯ 0ã€‚
            //f[][0][1] = Integer.MIN_VALUE;
            //ä¸å…è®¸äº¤æ˜“çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸å¯èƒ½æŒæœ‰è‚¡ç¥¨çš„ã€‚å› ä¸ºæˆ‘ä»¬çš„ç®—æ³•è¦æ±‚ä¸€ä¸ªæœ€å¤§å€¼ï¼Œæ‰€ä»¥åˆå§‹å€¼è®¾ä¸ºä¸€ä¸ªæœ€å°å€¼ï¼Œæ–¹ä¾¿å–æœ€å¤§å€¼ã€‚
            for (int i = 0; i <= n; i++) {
                f[i][0][1] = Integer.MIN_VALUE;
            }


            for (int i = 1; i <= n; i++) {
                for (int k = 1; k <= K; k++) {
                    //è§£é‡Šï¼šä»Šå¤©æˆ‘æ²¡æœ‰æŒæœ‰è‚¡ç¥¨ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼Œæˆ‘ä»è¿™ä¸¤ç§å¯èƒ½ä¸­æ±‚æœ€å¤§åˆ©æ¶¦ï¼š
                    //1ã€æˆ‘æ˜¨å¤©æŒæœ‰è‚¡ç¥¨ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kï¼›ä½†æ˜¯ä»Šå¤©æˆ‘ sell äº†ï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©æ²¡æœ‰æŒæœ‰è‚¡ç¥¨äº†ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¾ç„¶ä¸º kã€‚
                    //2ã€æˆ‘æ˜¨å¤©å°±æ²¡æœ‰æŒæœ‰ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kï¼›ç„¶åæˆ‘ä»Šå¤©é€‰æ‹© restï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©è¿˜æ˜¯æ²¡æœ‰æŒæœ‰ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¾ç„¶ä¸º kã€‚
                  //f[i][k][0] = Math.max(         ä»Šå¤©é€‰æ‹©å–,             ä»Šå¤©ä¼‘æ¯,ä¸å–)
                    f[i][k][0] = Math.max(f[i - 1][k][1] + prices[i - 1], f[i - 1][k][0]);

//                    è§£é‡Šï¼šä»Šå¤©æˆ‘æŒæœ‰è‚¡ç¥¨ï¼Œæœ‰ä¸¤ç§å¯èƒ½ï¼Œæˆ‘ä»è¿™ä¸¤ç§å¯èƒ½ä¸­æ±‚æœ€å¤§åˆ©æ¶¦ï¼š
//                    1ã€æˆ‘æ˜¨å¤©å°±æ²¡æœ‰æŒæœ‰ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º k - 1ï¼›ç„¶åæˆ‘ä»Šå¤©é€‰æ‹© buy ï¼Œæ‰€ä»¥ä»Šå¤©æˆ‘å°±æŒæœ‰è‚¡ç¥¨äº†ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kã€‚
//                    1ã€æˆ‘æ˜¨å¤©æŒæœ‰è‚¡ç¥¨ï¼Œä¸”æˆªè‡³æ˜¨å¤©æœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¸º kï¼›ä½†æ˜¯ä»Šå¤©æˆ‘ rest äº†ï¼Œæ‰€ä»¥æˆ‘ä»Šå¤©è¿˜æŒæœ‰ç€è‚¡ç¥¨ï¼Œæœ€å¤§äº¤æ˜“æ¬¡æ•°é™åˆ¶ä¾ç„¶ä¸º kã€‚
//                    f[i][k][1] = Math.max(         ä»Šå¤©é€‰æ‹©ä¹°,             ä»Šå¤©ä¼‘æ¯,ä¸ä¹°)
                    f[i][k][1] = Math.max(f[i - 1][k - 1][0] - prices[i - 1], f[i - 1][k][1]);

                }
            }
            return Math.max(f[n][K][0], f[n][K][1]);
        }
    }
}
```
