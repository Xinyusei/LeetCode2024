框架

1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；

或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

## 经典线性DP

### 最长递增子序列LIS

#### 板子-300.最长递增子序列

```java
package Type_.动态规划.经典线性DP.最长递增子序列LIS;

import java.util.Arrays;

/**
 * 300. 最长递增子序列
 * https://leetcode.cn/problems/longest-increasing-subsequence/description/
 * 2024-6-17
 */
public class a300最长递增子序列 {
    class Solution {
        public int lengthOfLIS(int[] nums) {
            int n = nums.length;
            int[] f = new int[n];
            //f[i] 表示以nums[0~i]的子序列且以nums[i]结尾的最长递增子序列的长度
            Arrays.fill(f, 1);
            int ret = 1;
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j])
                        f[i] = Math.max(f[i], f[j] + 1);
                }
                ret = Math.max(ret, f[i]);
            }
            System.out.println(Arrays.toString(f));
            return ret;
        }
    }
}

```



### 最长公共子序列

#### Hard.115.不同的子序列

```java
package Type_.动态规划.经典线性DP.最长公共子序列LCS;

/**
 * 115. 不同的子序列
 * https://leetcode.cn/problems/distinct-subsequences/description/
 * 2024-6-17
 */
public class a115不同的子序列 {
    class Solution {
        static final int MOD = (int) 1e9 + 7;

        public int numDistinct(String s, String t) {
            int m = s.length(), n = t.length();
            if (m < n)
                return 0;
            int[][] f = new int[m + 1][n + 1];
            //f[i][j]  定义 f[i][j] 为考虑 s 中 [0~i - 1] 个字符，t 中 [0~j - 1] 个字符的匹配个数。
            //base case
            for (int i = 0; i <= m; i++)
                f[i][0] = 1;

            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    //两种决策
                    //1.不让s[i]参与匹配 则 f[i][j] = f[i - 1][j]
                    f[i][j] = f[i - 1][j];
                    //2.让s[i]参与匹配, 则要求s[i] == t[j]
                    //s[i] = t[j]
                    if(s.charAt(i - 1) == t.charAt(j - 1)){
                        f[i][j] += f[i - 1][j - 1];
                    }
                }
            }
            return f[m][n];
        }
    }
}

```

> 总结
> 关于字符串匹配，通常有两种（你也可以理解为一种）通用的状态定义：
>
> ```bash
> 1. f[i][j] 表示第一个字符s中[0~i - 1]与t中[0~j - 1]的匹配结果
> 
> 2. f[i][j] 表示第一个字符s中[0~i - 1]与t中[0~j - 1] 且 最后一个字符串为t[j] 的匹配结果
> ```
>
> 
>
> 作者：宫水三叶
> 

## 背包问题

### 0-1背包

#### 基本



![image-20240604151046229](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-1.png)

##### Code

```java
class Solution1 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */

    int[] v;

    int[] w;

    int capacity;

    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        this.v = v;
        this.w = w;
        this.capacity = capacity;

        return dfs(capacity, v.length - 1);
    }

    /**
     * @param capacity 当前背包的容量
     * @param i        当前是第几个物品
     * @return 在不超过capacity容量的情况下, 在前i个物品中加入了背包的物品的最大价值
     */

    private int dfs(int capacity, int i) {
        if (i < 0)
            return 0;
        if (capacity < w[i])
            return dfs(capacity, i - 1);
        //当前操作 ： 枚举当前物品，选/不选
        //选:空出物品w[i]的重量后,在容量为capacity - w[i],从前i - 1个物品中得到的最大价值和
        //不选:在容量为capacity,从前i - 1个物品中得到的最大价值和
        return Math.max(dfs(capacity - w[i], i - 1) + v[i], dfs(capacity, i - 1));
    }
}


class Solution2 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */
    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        int n = v.length;
        int[][] f = new int[n + 1][capacity + 1];
        //定义：f[i][c] 的定义如下：对于前 i 个物品，当前背包的容量为 c，这种情况下可以装的最大价值是 dp[i][c]。
        //比如说，如果 f[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
        //注意这里的下标i从(1)开始,表示从前(1)个物品开始取。
        for (int i = 1; i <= n; i++) {
            for (int c = w[i]; c <= capacity; c++) {
                //如果把这第 i 个物品装入了背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了
                //接下来就要在剩余容量 c - w[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 f[i-1][c - w[i-1]]。
                //f[i][c] 应该等于  f[i-1][c - w[i-1]] + v[i-1]。
                //如果没有把这第 i 个物品装入背包，那么很显然，最大价值 f[i][c] 应该等于 f[i-1][w]，继承之前的结果。
                f[i][c] = Math.max(f[i - 1][c - w[i - 1]] + v[i - 1],f[i - 1][c]);
            }
        }
        return f[n][capacity];
    }
}


```





#### 常见变形

![image-20240604153612813](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-%E5%B8%B8%E8%A7%81%E5%8F%98%E5%BD%A2.png)



##### 1. 恰好满足的方案数-目标和

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

```java
/**
 * 494. 目标和
 * https://leetcode.cn/problems/target-sum/description/
 */

public class a494目标和 {
    class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x , sum - x
            //x - sum + x = target
            //x = (sum + target) / 2
            
            int sum = 0;
            int n = nums.length;
            for (int num : nums)
                sum += num;
            int target = sum + t;
            if (target < 0 || target % 2 != 0)
                return 0;
            target >>= 1;
            //f[i][w] 表示从前 i 个数中选出几个数,其和为 w 的方法数
            int[][] f = new int[n + 1][target + 1];
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= target; w++) {
                    //第i个数选：子问题变为从前i - 1个数中选出几个数,其和为w-nums[i - 1]的方法数
                    //第i个数不选:子问题变为从前i - 1个数中选出几个数,其和为w的方法数
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                    else
                        f[i][w] = f[i - 1][w - nums[i - 1]] + f[i - 1][w];
                }
            }
            return f[n][target];
        }
    }
}
```





##### 2. 是否能满足-分割等和子集

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

```java
class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x + y = sum;
            //x - y = t;
            //x = (sum + t) / 2;
            int sum = 0;
            for (int num : nums) {
                sum += num;
            }
            int s = sum + t, n = nums.length;
            if (s < 0 || (s & 1) != 0)
                return 0;
            s >>= 1;
            int[][] f = new int[n + 1][s + 1];
            //base case
            //定义：f[i][w] 的定义如下：对于前 i 个数，恰为好满足和为w 的方案数为 f[i][w]。
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= s; w++) {
                    //肯定不能选当前的数
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                        //可以选,考虑两种情况，不选 / 选
                    else
                        f[i][w] = f[i - 1][w] + f[i - 1][w - nums[i - 1]];
                }
            }
            return f[n][s];
        }
    }
```

- 类似题目 [1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

  > ```java
  >     class Solution {
  >         public int lastStoneWeightII(int[] stones) {
  >             //思路: 就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。
  >             //即变成 从 stones中 选 n个 石头，使得其在重量不超过t的情况下，其重量最大为t 。即背包所装的物品的重量和价值相等。
  >             //由于t < s / 2,所以结果为 (s - f[n][t]) - f[n][t]
  >             int s = 0, n = stones.length;
  >             for (int w : stones) {
  >                 s += w;
  >             }
  >             int t = s >> 1;
  >             int[][] f = new int[n + 1][t + 1];
  >             for (int i = 1; i <= n; i++) {
  >                 for (int j = 1; j <= t; j++) {
  >                     if (j >= stones[i - 1])
  >                         f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - stones[i - 1]] + stones[i - 1]);
  >                     else
  >                         f[i][j] = f[i - 1][j];
  >                 }
  >             }
  >             return s - f[n][t] * 2;
  >         }
  >     }
  > ```
  >
  > 



### 完全背包

#### 1-满足..的个数

##### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)

```java
package 代码随想录.动态规划.背包问题.完全背包;

import java.util.Arrays;

/**
 * @Author: ZJX
 * @Date: 2024/10/31
 * @Description: <a href="https://leetcode.cn/problems/combination-sum-iv/description/">377组合总和Ⅳ</a>
 */
public class a377组合总和Ⅳ {
    class Solution1 {
        int[] memo;

        public int combinationSum4(int[] nums, int target) {
            this.memo = new int[target];
            Arrays.fill(memo, -1);
            return dfs(nums, target);
        }

        public int dfs(int[] nums, int target) {
            if (target == 0)
                return 1;
            if (memo[target] != -1)
                return memo[target];
            int result = 0;
            for (int num : nums) {
                if (target >= num)
                    result += dfs(nums, target - num);
            }
            return memo[target] = result;
        }
    }

    class Solution2 {
        //二维DP
        public int combinationSum4(int[] nums, int target) {

            //nums[i] 最小为1,所以len最长为target
            int len = target;
            int[][] f = new int[len + 1][target + 1];
            //f[i][j] 表示 组合长度为 i 其和为j 的元素组合的个数
            //base case
            f[0][0] = 1;
            int result = 0;
            for (int i = 1; i <= len; i++) {
                for (int j = 1; j <= target; j++) {
                    for (int num : nums) {
                        f[i][j] = f[i - 1][j];
                        if (j >= num)
                            f[i][j] += f[i - 1][j - num];
                    }
                }
                result += f[i][target];
            }
            return result;
        }
    }
    
    class Solution2_1{
        //一维
        public int combinationSum4(int[] nums, int target) {
            int[] f = new int[target + 1];
            //f[i] 表示 从 nums中凑成 其和为i 的元素组合的个数
            //base case
            f[0] = 1;

            for (int i = 0; i <= target; i++) {
                for (int num : nums) {
                    if (i >= num)
                        f[i] += f[i - num];
                }
            }
            //System.out.println(Arrays.toString(f));
            return f[target];
        }
    }
}
```

类似题目

#####[57. 爬楼梯kamacoder.com](https://kamacoder.com/problempage.php?pid=1067)

```java
package 代码随想录.KamaCoder.完全背包;

import java.util.Scanner;

/**
 * @Author: ZJX
 * @Date: 2024/10/31
 * @Description:
 */
public class w57爬楼梯进阶 {

    public class Main {

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            //f[i] 表示有 f[i]中方法爬到第 i 层楼梯
            int[] f = new int[n + 1];
            f[0] = 1;
            //f[i] 由 f[i - x(x属于[1,m]决定)]
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    if (i >= j)
                        f[i] += f[i - j];
                }
            }
            System.out.println(f[n]);
        }
    }
}
```



#### 2.是否满足...

[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/description/)

```java
package 代码随想录.动态规划.背包问题.完全背包;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a139单词拆分 {
    class Solution {
        public boolean wordBreak(String s, List<String> wordDict) {
            int n = s.length();
            boolean[] f = new boolean[n + 1];
            Arrays.fill(f, false);
            f[0] = true;

            for (int i = 1; i <= n; i++) {
                for (String sub : wordDict) {
                    int m = sub.length();
                    if (i < m)
                        continue;
                    String cur = s.substring(i - m, i);
                    if (cur.equals(sub))
                        f[i] = f[i] || f[i - m];
                }
            }
            return f[n];
        }
    }
}
```
