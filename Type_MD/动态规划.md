框架

1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；

或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

# 一.入门DP



## 1.1 爬楼梯

### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)

```java
package 代码随想录.动态规划.背包问题.完全背包;

import java.util.Arrays;

/**
 * @Author: ZJX
 * @Date: 2024/10/31
 * @Description: <a href="https://leetcode.cn/problems/combination-sum-iv/description/">377组合总和Ⅳ</a>
 */
public class a377组合总和Ⅳ {
    class Solution1 {
        int[] memo;

        public int combinationSum4(int[] nums, int target) {
            this.memo = new int[target];
            Arrays.fill(memo, -1);
            return dfs(nums, target);
        }

        public int dfs(int[] nums, int target) {
            if (target == 0)
                return 1;
            if (memo[target] != -1)
                return memo[target];
            int result = 0;
            for (int num : nums) {
                if (target >= num)
                    result += dfs(nums, target - num);
            }
            return memo[target] = result;
        }
    }

    class Solution2 {
        //二维DP
        public int combinationSum4(int[] nums, int target) {

            //nums[i] 最小为1,所以len最长为target
            int len = target;
            int[][] f = new int[len + 1][target + 1];
            //f[i][j] 表示 组合长度为 i 其和为j 的元素组合的个数
            //base case
            f[0][0] = 1;
            int result = 0;
            for (int i = 1; i <= len; i++) {
                for (int j = 1; j <= target; j++) {
                    for (int num : nums) {
                        f[i][j] = f[i - 1][j];
                        if (j >= num)
                            f[i][j] += f[i - 1][j - num];
                    }
                }
                result += f[i][target];
            }
            return result;
        }
    }
    
    class Solution2_1{
        //一维
        public int combinationSum4(int[] nums, int target) {
            int[] f = new int[target + 1];
            //f[i] 表示 从 nums中凑成 其和为i 的元素组合的个数
            //base case
            f[0] = 1;

            for (int i = 0; i <= target; i++) {
                for (int num : nums) {
                    if (i >= num)
                        f[i] += f[i - num];
                }
            }
            //System.out.println(Arrays.toString(f));
            return f[target];
        }
    }
}
```

类似题目

####[57. 爬楼梯kamacoder.com](https://kamacoder.com/problempage.php?pid=1067)

```java
package 代码随想录.KamaCoder.完全背包;

import java.util.Scanner;

/**
 * @Author: ZJX
 * @Date: 2024/10/31
 * @Description:
 */
public class w57爬楼梯进阶 {

    public class Main {

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            //f[i] 表示有 f[i]中方法爬到第 i 层楼梯
            int[] f = new int[n + 1];
            f[0] = 1;
            //f[i] 由 f[i - x(x属于[1,m]决定)]
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    if (i >= j)
                        f[i] += f[i - j];
                }
            }
            System.out.println(f[n]);
        }
    }
}
```



## 1.2 打家劫舍

###针对索引下标的

#### I

#### II

#### III

[337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/description/)

```java
package 代码随想录.动态规划.打家劫舍;

import Common.TreeNode;

import java.util.HashMap;

/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a337打家劫舍III {
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     * int val;
     * TreeNode left;
     * TreeNode right;
     * TreeNode() {}
     * TreeNode(int val) { this.val = val; }
     * TreeNode(int val, TreeNode left, TreeNode right) {
     * this.val = val;
     * this.left = left;
     * this.right = right;
     * }
     * }
     */
    class Solution {
        HashMap<TreeNode, Integer> memo = new HashMap<>();

        public int rob(TreeNode root) {
            if (root == null)
                return 0;
            if (memo.containsKey(root))
                return memo.get(root);

            int do_it = root.val +
                    (root.left == null ? 0 : rob(root.left.left) + rob(root.left.right)) +
                    (root.right == null ? 0 : rob(root.right.left) + rob(root.right.right));
            int not_do = rob(root.left) + rob(root.right);

            int res = Math.max(do_it, not_do);
            memo.put(root, res);

            return res;
        }
    }
}
```



### 针对值域

[740. 删除并获得点数 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-and-earn/description/)

```java
package Type_.动态规划.打家劫舍;

import java.util.HashMap;
import java.util.HashSet;

/**
 * 740. 删除并获得点数
 * https://leetcode.cn/problems/delete-and-earn/description/
 */
public class a740删除并获得点数 {
    class Solution {
        public int deleteAndEarn(int[] nums) {
            //删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素，

            //直观：统计每个元素出现次数 -> 某个元素被删除了,相当于这个元素对应的元素和不能选了
            //将 nums[i] - 1  nums[i]  nums[i] + 1 转化为横轴,就变成了打家劫舍问题
            int maxVal = 0;
            //计算最大值
            for (int num : nums)
                maxVal = Math.max(maxVal, num);
            int[] sum = new int[maxVal + 1];
            //计算 每个元素的和
            for (int num : nums)
                sum[num] += num;
            int[] f = new int[maxVal + 1];
            //f[i] 表示nums[0 - i] 删除某点数获得的最大值 ,相当于选了f[i] 不能选 f[i - 1] 和 f[i + 1];
            f[0] = sum[0];
            f[1] = Math.max(sum[0], sum[1]);
            //0 0 2 3 4
            for (int i = 2; i < f.length; i++) {
                f[i] = Math.max(f[i - 1],f[i - 2] + sum[i]);
            }
            return f[maxVal];
        }
    }
}
```



**重点在于 值域->索引下标**



[3186. 施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/)

```java
package Type_.动态规划.打家劫舍;

import java.util.*;
import java.util.function.BiFunction;

/**
 * @Author: ZJX
 * @Date: 2024/12/02
 * @Description:
 */
public class a3186施咒的最大总伤害 {
    class Solution1 {
        //OOM
        public long maximumTotalDamage(int[] power) {
            HashMap<Integer, Long> record = new HashMap<>();
            int mx = 0;
            for (int v : power) {
                record.put(v, record.getOrDefault(v, 0L) + v);
                mx = Math.max(mx, v);
            }
            long[] f = new long[mx + 1];
            f[0] = record.getOrDefault(0, 0L);
            f[1] = Math.max(record.getOrDefault(0, 0L), record.getOrDefault(1, 0L));
            if (mx >= 2)
                f[2] = Math.max(record.getOrDefault(2, 0L), Math.max(record.getOrDefault(0, 0L), record.getOrDefault(1, 0L)));
            for (int i = 3; i <= mx; i++) {
                f[i] = Math.max(Math.max(f[i - 1], f[i - 2]), f[i - 3] + record.getOrDefault(i, 0L));
            }
            return f[mx];
        }
    }

    class Solution2 {
        //1,6,6,7

        //1,1,3,4
        public long maximumTotalDamage(int[] power) {
            HashMap<Integer, Integer> record = new HashMap<>();
            int mx = 0;
            for (int v : power) {
                record.put(v, record.getOrDefault(v, 0) + 1);
                mx = Math.max(mx, v);
            }
            long p0 = 0;
            long p1 = (long) record.getOrDefault(1, 0);
            long p2 = 0;
            if (mx >= 2)
                p2 = Math.max(record.getOrDefault(2, 0) * 2, Math.max(p0, p1));
            long p3 = Math.max(Math.max(p2, p1), p0 + record.getOrDefault(3, 0) * 3L);
            for (int i = 3; i <= mx; i++) {
                p3 = Math.max(Math.max(p2, p1), p0 + (long) record.getOrDefault(i, 0) * i);
                p0 = p1;
                p1 = p2;
                p2 = p3;
            }
            //p0 p1 p2 p3
            //   p0 p1 p2 p3
            return p3;
        }
    }


    class Solution3 {
        class Solution {
            public long maximumTotalDamage(int[] power) {
                Map<Integer, Integer> cnt = new HashMap<>();
                for (int x : power) {
                    //统计每个元素的出现次数，记到哈希表 cnt 中。
                    cnt.merge(x, 1, Integer::sum);
                }
                int n = cnt.size();
                int[] arr = new int[n];
                int idx = 0;
                //将哈希表的 key 整理到数组 arr 中，把 arr 按照从小到大的顺序排序。
                for (Integer x : cnt.keySet()) {
                    arr[idx++] = x;
                }
                Arrays.sort(arr);

                //arr: 1,6,7
                //arr: 1,3,4
                //定义f[i] 表示从arr[0] 到 arr[i - 1] 中选择,可以得到的伤害之和的最大值
                long[] f = new long[n + 1];
                int j = 0;
                for (int i = 1; i <= n; i++) {
                    int x = arr[i - 1];
                    while (arr[j] < x - 2) {
                        j++;
                    }
                    //如果不选当前的,则f[i] = f[i - 1]
                    //如果选,则伤害值等于 arr[i - 1] - 1 ,arr[i - 1] - 2的不能选, 从arr[0] 到 arr[j - 1]中选择,可以得到的伤害的最大值,其中j最小的满足arr[j] >= a[i - 1] - 2
                    f[i] = Math.max(f[i - 1], f[j] + (long) x * cnt.get(x));
                }
                return f[n];
            }
        }
    }
}
```



## 1.3最大子数组和(最大子段和)

![image-20241202235055974](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/1.3-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C(%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C).png)









#二.网格图DP

## 2.1基础



## 2.2进阶

[174. 地下城游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/dungeon-game/description/) - 区别于 64题的[最小路径和]

这道题是有状态的，需要倒序DP

```java
class Solution1 {
    /**
     * 记忆化搜索
     */
    int[][] memo;

    public int calculateMinimumHP(int[][] dungeon) {
        int m = dungeon.length, n = dungeon[0].length;
        memo = new int[m][n];
        for (int[] e : memo) {
            //初始化为-1,表示没有遍历过
            Arrays.fill(e, -1);
        }
        return dfs(0, 0, dungeon);
    }

    //从 grid[i][j] 到达终点（右下角）所需的最少初始生命值是 dfs(grid, i, j)
    private int dfs(int x, int y, int[][] g) {
        int m = g.length, n = g[0].length;

        //base case
        if (x == m - 1 && y == n - 1) {
            return Math.max(1, 1 - g[x][y]);
        }
        if (x == m || y == n)
            return Integer.MAX_VALUE;
        if (memo[x][y] != -1)
            return memo[x][y];
        int res = Math.max(
                Math.min(dfs(x + 1, y, g), dfs(x, y + 1, g)) - g[x][y],
                1);
        return memo[x][y] = res;
    }
}

class Solution2 {
    //这道题的dp是倒序的，这点很重要，为什么不能像【最小路径和】一样是正序的？因为【最小路径和】是无状态的，你会发现【最小路径和】倒序dp也是可以的
    //这道题由于有“加血”的过程，只能依赖后面的值判断需要的血量。所以这里的dp[i][j]表达的意思是：“从（i，j）出发，到达终点需要最少的血量”。
    //因此，正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp
    class Solution {
        public int calculateMinimumHP(int[][] dungeon) {
            int m = dungeon.length, n = dungeon[0].length;
            int[][] f = new int[m][n];
            //f[i][j] 表示： 从 i,j 出发,到达终点所需要的最少的血量

            //base case
            f[m - 1][n - 1] = Math.max(1, 1 - dungeon[m - 1][n - 1]);
            for (int i = m - 2; i >= 0; i--)
                f[i][n - 1] = Math.max(1, f[i + 1][n - 1] - dungeon[i][n - 1]);

            for (int j = n - 2; j >= 0; j--)
                f[m - 1][j] = Math.max(1, f[m - 1][j + 1] - dungeon[m - 1][j]);

            for (int i = m - 2; i >= 0; i--) {
                for (int j = n - 2; j >= 0; j--) {
                    f[i][j] = Math.max(1, Math.min(f[i + 1][j], f[i][j + 1]) - dungeon[i][j]);
                }
            }
            return f[0][0];
        }
    }
}

class Solution3 {
    //这道题的dp是倒序的，这点很重要，为什么不能像【最小路径和】一样是正序的？因为【最小路径和】是无状态的，你会发现【最小路径和】倒序dp也是可以的
    //这道题由于有“加血”的过程，只能依赖后面的值判断需要的血量。所以这里的dp[i][j]表达的意思是：“从（i，j）出发，到达终点需要最少的血量”。
    //因此，正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp
    class Solution {
        public int calculateMinimumHP(int[][] dungeon) {
            int m = dungeon.length, n = dungeon[0].length;
            int[][] f = new int[m + 1][n + 1];
            //f[i][j] 表示： 从 i,j 出发,到达终点所需要的最少的血量
            //base case
            for (int[] row : f) {
                Arrays.fill(row, Integer.MAX_VALUE);
            }
            f[m][n - 1] = f[m - 1][n] = 1;
            for (int i = m - 1; i >= 0; i--) {
                for (int j = n - 1; j >= 0; j--) {
                    f[i][j] = Math.max(1, Math.min(f[i + 1][j], f[i][j + 1]) - dungeon[i][j]);
                }
            }
            return f[0][0];
        }
    }
}
```



### 网格图中的递增路径数目/最大长度

[2328. 网格图中递增路径的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/)

[329. 矩阵中的最长递增路径 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)



2328解法：

```java
package Type_.动态规划.二_网格图DP.进阶;

/**
 * @Author: ZJX
 * @Date: 2024/12/03
 * @Description:
 */
public class a2328网格图中递增路径的数目 {
    class Solution {
        public static final int mod = (int) 1e9 + 7;
        int[][] f;
        public final static int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        public int countPaths(int[][] s) {
            int m = s.length, n = s[0].length;
            f = new int[m][n];
            int res = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    res = (res + dfs(i, j, s)) % mod;
                }
            }
            return res;
        }

        private int dfs(int x, int y, int[][] s) {
            //找到以x,y为起始点的LIS
            if (f[x][y] != 0)
                return f[x][y];

            int res = 1;
            for (int[] d : dir) {
                int nx = x + d[0], ny = y + d[1];
                //指明方向 往 合法 且 大于当前值的方向移动
                if (valid(nx, ny, s) && s[nx][ny] > s[x][y]) {
                    res = (res % mod + dfs(nx, ny, s) % mod) % mod;
                }
            }
            return f[x][y] = res;
        }

        private boolean valid(int x, int y, int[][] s) {

            int m = s.length, n = s[0].length;
            //不合法
            return x >= 0 && x < m && y >= 0 && y < n;
        }
    }
}
```







### 三维DP

需要额外保存状态

[688. 骑士在棋盘上的概率 - 力扣（LeetCode）](https://leetcode.cn/problems/knight-probability-in-chessboard/description/)









# 背包问题

## 0-1背包

### 基本



![image-20240604151046229](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-1.png)

#### Code

```java
class Solution1 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */

    int[] v;

    int[] w;

    int capacity;

    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        this.v = v;
        this.w = w;
        this.capacity = capacity;

        return dfs(capacity, v.length - 1);
    }

    /**
     * @param capacity 当前背包的容量
     * @param i        当前是第几个物品
     * @return 在不超过capacity容量的情况下, 在前i个物品中加入了背包的物品的最大价值
     */

    private int dfs(int capacity, int i) {
        if (i < 0)
            return 0;
        if (capacity < w[i])
            return dfs(capacity, i - 1);
        //当前操作 ： 枚举当前物品，选/不选
        //选:空出物品w[i]的重量后,在容量为capacity - w[i],从前i - 1个物品中得到的最大价值和
        //不选:在容量为capacity,从前i - 1个物品中得到的最大价值和
        return Math.max(dfs(capacity - w[i], i - 1) + v[i], dfs(capacity, i - 1));
    }
}


class Solution2 {
    /**
     * 给你一个可装载重量为 capacity 的背包和 n 个物品,每个物品有重量和价值两个属性。
     * 其中第 i 个物品的重量为 w[i] ,价值为 v[i] ,现在让你用这个背包装物品,最多能装的价值是多少?
     * n = 3, capacity = 4
     * w = [2, 1, 3]
     * v = [4, 2, 3]
     *
     * @param v        第i个物品的价值
     * @param w        第i个物品的体积
     * @param capacity 背包容量
     * @return 在不超过背包容量的情况下，背包中放入的物品的最大价值
     */
    public int zero_one_knapsack(int[] v, int[] w, int capacity) {
        int n = v.length;
        int[][] f = new int[n + 1][capacity + 1];
        //定义：f[i][c] 的定义如下：对于前 i 个物品，当前背包的容量为 c，这种情况下可以装的最大价值是 dp[i][c]。
        //比如说，如果 f[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
        //注意这里的下标i从(1)开始,表示从前(1)个物品开始取。
        for (int i = 1; i <= n; i++) {
            for (int c = w[i]; c <= capacity; c++) {
                //如果把这第 i 个物品装入了背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了
                //接下来就要在剩余容量 c - w[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 f[i-1][c - w[i-1]]。
                //f[i][c] 应该等于  f[i-1][c - w[i-1]] + v[i-1]。
                //如果没有把这第 i 个物品装入背包，那么很显然，最大价值 f[i][c] 应该等于 f[i-1][w]，继承之前的结果。
                f[i][c] = Math.max(f[i - 1][c - w[i - 1]] + v[i - 1],f[i - 1][c]);
            }
        }
        return f[n][capacity];
    }
}


```





### 常见变形

![image-20240604153612813](./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/0-1%E8%83%8C%E5%8C%85-%E5%B8%B8%E8%A7%81%E5%8F%98%E5%BD%A2.png)



#### 1. 恰好满足的方案数-目标和

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/description/)

```java
/**
 * 494. 目标和
 * https://leetcode.cn/problems/target-sum/description/
 */

public class a494目标和 {
    class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x , sum - x
            //x - sum + x = target
            //x = (sum + target) / 2
            
            int sum = 0;
            int n = nums.length;
            for (int num : nums)
                sum += num;
            int target = sum + t;
            if (target < 0 || target % 2 != 0)
                return 0;
            target >>= 1;
            //f[i][w] 表示从前 i 个数中选出几个数,其和为 w 的方法数
            int[][] f = new int[n + 1][target + 1];
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= target; w++) {
                    //第i个数选：子问题变为从前i - 1个数中选出几个数,其和为w-nums[i - 1]的方法数
                    //第i个数不选:子问题变为从前i - 1个数中选出几个数,其和为w的方法数
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                    else
                        f[i][w] = f[i - 1][w - nums[i - 1]] + f[i - 1][w];
                }
            }
            return f[n][target];
        }
    }
}
```





#### 2. 是否能满足-分割等和子集

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

```java
class Solution {
        public int findTargetSumWays(int[] nums, int t) {
            //x + y = sum;
            //x - y = t;
            //x = (sum + t) / 2;
            int sum = 0;
            for (int num : nums) {
                sum += num;
            }
            int s = sum + t, n = nums.length;
            if (s < 0 || (s & 1) != 0)
                return 0;
            s >>= 1;
            int[][] f = new int[n + 1][s + 1];
            //base case
            //定义：f[i][w] 的定义如下：对于前 i 个数，恰为好满足和为w 的方案数为 f[i][w]。
            f[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                for (int w = 0; w <= s; w++) {
                    //肯定不能选当前的数
                    if (w < nums[i - 1])
                        f[i][w] = f[i - 1][w];
                        //可以选,考虑两种情况，不选 / 选
                    else
                        f[i][w] = f[i - 1][w] + f[i - 1][w - nums[i - 1]];
                }
            }
            return f[n][s];
        }
    }
```

- 类似题目 [1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

  > ```java
  >     class Solution {
  >         public int lastStoneWeightII(int[] stones) {
  >             //思路: 就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。
  >             //即变成 从 stones中 选 n个 石头，使得其在重量不超过t的情况下，其重量最大为t 。即背包所装的物品的重量和价值相等。
  >             //由于t < s / 2,所以结果为 (s - f[n][t]) - f[n][t]
  >             int s = 0, n = stones.length;
  >             for (int w : stones) {
  >                 s += w;
  >             }
  >             int t = s >> 1;
  >             int[][] f = new int[n + 1][t + 1];
  >             for (int i = 1; i <= n; i++) {
  >                 for (int j = 1; j <= t; j++) {
  >                     if (j >= stones[i - 1])
  >                         f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - stones[i - 1]] + stones[i - 1]);
  >                     else
  >                         f[i][j] = f[i - 1][j];
  >                 }
  >             }
  >             return s - f[n][t] * 2;
  >         }
  >     }
  > ```
  >
  > 



[3180. 执行操作可获得的最大总奖励 I - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/description/)







## 完全背包

### 1-满足..的个数



### 2.是否满足...

[139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/description/)

```java
package 代码随想录.动态规划.背包问题.完全背包;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a139单词拆分 {
    class Solution {
        public boolean wordBreak(String s, List<String> wordDict) {
            int n = s.length();
            boolean[] f = new boolean[n + 1];
            Arrays.fill(f, false);
            f[0] = true;

            for (int i = 1; i <= n; i++) {
                for (String sub : wordDict) {
                    int m = sub.length();
                    if (i < m)
                        continue;
                    String cur = s.substring(i - m, i);
                    if (cur.equals(sub))
                        f[i] = f[i] || f[i - m];
                }
            }
            return f[n];
        }
    }
}
```





#四.线性DP



###4.1最长公共子序列(LCS)

#### Hard.115.不同的子序列

```java
package Type_.动态规划.经典线性DP.最长公共子序列LCS;

/**
 * 115. 不同的子序列
 * https://leetcode.cn/problems/distinct-subsequences/description/
 * 2024-6-17
 */
public class a115不同的子序列 {
    class Solution {
        static final int MOD = (int) 1e9 + 7;

        public int numDistinct(String s, String t) {
            int m = s.length(), n = t.length();
            if (m < n)
                return 0;
            int[][] f = new int[m + 1][n + 1];
            //f[i][j]  定义 f[i][j] 为考虑 s 中 [0~i - 1] 个字符，t 中 [0~j - 1] 个字符的匹配个数。
            //base case
            for (int i = 0; i <= m; i++)
                f[i][0] = 1;

            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    //两种决策
                    //1.不让s[i]参与匹配 则 f[i][j] = f[i - 1][j]
                    f[i][j] = f[i - 1][j];
                    //2.让s[i]参与匹配, 则要求s[i] == t[j]
                    //s[i] = t[j]
                    if(s.charAt(i - 1) == t.charAt(j - 1)){
                        f[i][j] += f[i - 1][j - 1];
                    }
                }
            }
            return f[m][n];
        }
    }
}

```

> 总结
> 关于字符串匹配，通常有两种（你也可以理解为一种）通用的状态定义：
>
> ```bash
> 1. f[i][j] 表示第一个字符s中[0~i - 1]与t中[0~j - 1]的匹配结果
> 
> 2. f[i][j] 表示第一个字符s中[0~i - 1]与t中[0~j - 1] 且 最后一个字符串为t[j] 的匹配结果
> ```
>
> 
>
> 作者：宫水三叶



###4.2最长递增子序列(LIS)

做法有很多：

- 枚举选哪个（见讲解）。
- 贪心+二分（见讲解）。
- 计算 𝑎 和把 a 排序后的数组 sortedA 的最长公共子序列。
- 数据结构优化（见 2407 题）。

```java
package Type_.动态规划.经典线性DP.最长递增子序列LIS;

import java.util.Arrays;

/**
 * 300. 最长递增子序列
 * https://leetcode.cn/problems/longest-increasing-subsequence/description/
 * 2024-6-17
 */
public class a300最长递增子序列 {
    class Solution {
        public int lengthOfLIS(int[] nums) {
            int n = nums.length;
            int[] f = new int[n];
            //f[i] 表示以nums[0~i]的子序列且以nums[i]结尾的最长递增子序列的长度
            Arrays.fill(f, 1);
            int ret = 1;
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (nums[i] > nums[j])
                        f[i] = Math.max(f[i], f[j] + 1);
                }
                ret = Math.max(ret, f[i]);
            }
            System.out.println(Arrays.toString(f));
            return ret;
        }
    }
}

```



优化：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        //g[i] 的 定义为 : 长度为 i + 1 的 递增子序列的 末尾元素的最小值
        List<Integer> g = new ArrayList<>();
        for (int x : nums) {
            int j = lowerBound(g, x);
            if (j == g.size())
                g.add(x);
            else
                g.set(j, x);
        }
        return g.size();
    }


    //大于等于 target 的最小元素下标
    private int lowerBound(List<Integer> g, int target) {
        int left = 0, right = g.size();
        while (left < right) {
            int mid = (right - left) / 2 + left;
            //[left,mid) mid [mid,right)
            if (g.get(mid) >= target)
                right = mid;
            else
                left = mid + 1;
        }
        return right;
    }
}
```





LIS的个数

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        int[] f = new int[n], g = new int[n];
        //f[i] 表示以nums[0~i]的子序列且以nums[i]结尾的最长递增子序列的长度
        //g[i] 为考虑以 nums[i] 结尾的最长递增子序列的个数。
        int mx = 1;
        for (int i = 0; i < n; i++) {
            f[i] = g[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    //满足 f[i]<f[j]+1：说明 f[i] 会被 f[j]+1 直接更新，此时同步直接更新 g[i]=g[j] 即可；

                    //相当于 第一次得到f[i]
                    if (f[i] < f[j] + 1) {
                        f[i] = f[j] + 1;
                        g[i] = g[j];

                    } else if (f[i] == f[j] + 1) {
                        //满足 f[i]=f[j]+1：说明找到了一个新的符合条件的前驱，此时将值继续累加到方案数当中，即有 g[i]+=g[j]。
                        //相当于 并非第一次得到f[i]
                        g[i] += g[j];
                    }
                }
            }
            mx = Math.max(mx, f[i]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (f[i] == mx)
                ans += g[i];
        }
        return ans;
    }
}
```









# 经典







## 股票买卖

**每天都有三种「选择」**：买入、卖出、无操作，我们用 `buy`, `sell`, `rest` 表示这三种选择。

**我们把一次买入和一次卖出定义为一次「交易」**。



**这个问题的「状态」有三个**，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 `rest` 的状态，我们不妨用 1 表示持有，0 表示没有持有）。



然后我们用一个三维数组就可以装下这几种状态的全部组合：

```python
dp[i][k][0 or 1]
0 <= i <= n , 1 <= k <= K
n 为第几天，大 K 为交易数的上限，0 和 1 代表是否持有股票。
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 1 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

`dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 `dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。



注意 `k` 的限制，在选择 `buy` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 `k` 应该减小 1。

因为交易是从 `buy` 开始，如果 `buy` 的选择不改变交易次数 `k` 的话，会出现交易次数超出限制的的错误。



```java
f[i][k][0] = Math.max(f[i - 1][k][1] + prices[i - 1], f[i - 1][k][0]);
//f[i][k][0] = Math.max(         今天选择卖,             今天休息,不卖)
```

解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：

1. 我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最大交易次数限制依然为 k。
2. 我昨天就没有持有，且截至昨天最大交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最大交易次数限制依然为 k。



```java
f[i][k][1] = Math.max(f[i - 1][k - 1][0] - prices[i - 1], f[i - 1][k][1]);
//f[i][k][1] = Math.max(         今天选择买,             今天休息,不买)
```

解释：今天我持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 k - 1；然后我今天选择 buy ，所以今天我就持有股票了，最大交易次数限制为 k。

2. 我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 rest 了，所以我今天还持有着股票，最大交易次数限制依然为 k。



base case:

```java
//f[0][...][0] = 0;
//因为 i 是从 1 开始的，所以 i = 0 意味着还没有开始，这时候的利润当然是 0。

//f[0][...][1] = Integer.MIN_VALUE;
//还没开始的时候，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
for (int k = 0; k <= K; k++) {
    f[0][k][1] = Integer.MIN_VALUE;
}

//f[][0][0] = 0;
//因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。
//f[][0][1] = Integer.MIN_VALUE;
//不允许交易的情况下，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
for (int i = 0; i <= n; i++) {
    f[i][0][1] = Integer.MIN_VALUE;
}
```

### [188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

```java
/**
 * @Author: ZJX
 * @Date: 2024/11/14
 * @Description:
 */
public class a188买卖股票的最佳时机IV {
    class Solution {
        public int maxProfit(int K, int[] prices) {
            int n = prices.length;
            int[][][] f = new int[n + 1][K + 1][2];

            //base case
            //f[0][...][0] = 0;
            //因为 i 是从 1 开始的，所以 i = 0 意味着还没有开始，这时候的利润当然是 0。

            //f[0][...][1] = Integer.MIN_VALUE;
            //还没开始的时候，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
            for (int k = 0; k <= K; k++) {
                f[0][k][1] = Integer.MIN_VALUE;
            }

            //f[][0][0] = 0;
            //因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。
            //f[][0][1] = Integer.MIN_VALUE;
            //不允许交易的情况下，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
            for (int i = 0; i <= n; i++) {
                f[i][0][1] = Integer.MIN_VALUE;
            }


            for (int i = 1; i <= n; i++) {
                for (int k = 1; k <= K; k++) {
                    //解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：
                    //1、我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最大交易次数限制依然为 k。
                    //2、我昨天就没有持有，且截至昨天最大交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最大交易次数限制依然为 k。
                  //f[i][k][0] = Math.max(         今天选择卖,             今天休息,不卖)
                    f[i][k][0] = Math.max(f[i - 1][k][1] + prices[i - 1], f[i - 1][k][0]);

//                    解释：今天我持有股票，有两种可能，我从这两种可能中求最大利润：
//                    1、我昨天就没有持有，且截至昨天最大交易次数限制为 k - 1；然后我今天选择 buy ，所以今天我就持有股票了，最大交易次数限制为 k。
//                    1、我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 rest 了，所以我今天还持有着股票，最大交易次数限制依然为 k。
//                    f[i][k][1] = Math.max(         今天选择买,             今天休息,不买)
                    f[i][k][1] = Math.max(f[i - 1][k - 1][0] - prices[i - 1], f[i - 1][k][1]);

                }
            }
            return Math.max(f[n][K][0], f[n][K][1]);
        }
    }
}
```
